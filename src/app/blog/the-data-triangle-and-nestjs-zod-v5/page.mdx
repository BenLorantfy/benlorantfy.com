import Image from 'next/image';
import dataTriangle from '~/assets/data-triangle.png'

## The Data Triangle
(Announcing nestjs-zod v5)

Before I get too far: `nestjs-zod` version 5 is out!  You can install it today:

```
npm install nestjs-zod@latest
```

In this release there's some new features (including zod v4 support ðŸŽ‰), bug fixes, and some mostly minor breaking changes.  You can check out the MIGRATION.md file for details

But in this post I mostly wanted to talk about what makes me excited about `nestjs-zod`.  

`nestjs-zod` helps you ensure your run-time, compile-time, and docs-time representations of your data schemas are always in sync.  

I couldn't find a name for this principle ("End to End Type Safety" is close, but not quite), so I made one up: "The Data Triangle"

<Image
    alt="The Data Triangle"
    src={dataTriangle}
    width={1228}
    height={748}
    width={600}
/>

"The Data Triangle" allows you to make this powerful statement:

> If the application compiles and there's no errors, then consumers are guaranteed to get data that matches your documented API contract

This is huge.

In my experience, a significant portion of bugs I've run into are caused by APIs not returning data that matches their contract.  But if you have a compile-time guarantee that the returned data matches the documented API contract, it eliminates an entire class of bugs.

Let me give a quick example of adherence to "The Data Triangle" in `nestjs-zod`:
```ts
import { z } from 'zod'
import { createZodDto, ZodResponse } from 'nestjs-zod'

class PostDto extends createZodDto(z.object({
  title: z.string().describe('The title of the post'),
  content: z.string().describe('The content of the post'),
  authorId: z.number().describe('The ID of the author of the post'),
})) {}

@Controller('posts')
export class PostsController {
    @Get(':id')
    @ZodResponse({ type: PostDto })
    getById(@Param('id') id: string) {
      return {
        title: 'Hello',
        content: 'World',
        authorId: 1,
      };
    }
}
```
The key here is `@ZodResponse`, which is a decorator provided by `nestjs-zod`

`@ZodResponse` does 3 main things:
1. If used in combination with `nestjs/swagger`, it generates an OpenAPI schema based off `PostDto` (docs-time)
2. It serializes the response with `PostDto`, and throws an error if the returned data is invalid (run-time)
3. It throws a typescript error if the method returns data that doesn't match `PostDto` (compile-time)

Because you have one decorator doing all of these things, it makes it impossible for them to get out of sync

Note that The Data Triangle is not only applicable in `nestjs`.  You can theoretically adopt "The Data Triangle" in any API that is using a framework/language that has a compile step.  I can guarantee you your consumers will thank you ðŸ™‚

## What about `class-validator` ?

There are several drawbacks with `class-validator` compared to `zod`.  It uses a more verbose syntax, for example.  But it also doesn't adhere to The Data Triangle, because it's possible for the compile-time, run-time, and docs-time types to get out of sync

For example, I can write this code:
```ts
export class Post {
  @ApiProperty({
   type: Boolean,
  })
  @IsString()
  rating: number;
}
```
This will not throw a compile-time error if the API returns a number.  At run-time it will throw an error expecting a string, and in the api docs it will say it's a boolean.

And if something is possible to get out of sync, it will get out of sync.

## Isn't this End-to-End Type Safety?

This is not quite end-to-end type safety

In End-to-End Type Safety, the _consumer_ will get a compile-time error if they try to call or use the API incorrectly

Frameworks with End-to-End Type Safety include `tRPC`, `react-router` and `nest.js`

You can extend this approach to achieve "End-to-End Type Safety" if you generate a service client using the openapi doc generated by `nestjs/swagger`, using something like [`openapi-ts`](https://www.npmjs.com/package/openapi-typescript)